    public List<OrderDto> getOrders(String search, String vendor, String courier,
                                    String customer, String status) {
        String searchFilter = (search == null || search.isBlank()) ? null : search.toLowerCase();
        String vendorFilter = (vendor == null || vendor.isBlank()) ? null : vendor.toLowerCase();
        String courierFilter = (courier == null || courier.isBlank()) ? null : courier.toLowerCase();
        String customerFilter = (customer == null || customer.isBlank()) ? null : customer.toLowerCase();
        String statusFilter = (status == null || status.isBlank()) ? null : status.toLowerCase();

        Map<String, Object> filters = new HashMap<>();
        if (statusFilter != null) filters.put("status", statusFilter);
        if (vendorFilter != null) filters.put("restaurant.name", vendorFilter);
        if (courierFilter != null) filters.put("delivery.fullName", courierFilter);
        if (customerFilter != null) filters.put("customer.fullName", customerFilter);

        List<String> searchable = List.of(
            "status",
            "deliveryAddress",
            "coupon.code",
            "restaurant.name",
            "delivery.fullName",
            "customer.fullName",
            "createdAt",
            "updatedAt",
            "rating.rating"
        );

        List<Order> results = orderDao.search(filters, searchFilter, searchable);
        return results.stream().map(OrderDto::new).toList();


    }

        public List<T> search2(Map<String, Object> filters,
                      String searchTerm,
                      List<String> searchableFields) {

    if (filters == null) filters = new HashMap<>();
    String keyword = (searchTerm == null || searchTerm.isBlank()) ? null : searchTerm.toLowerCase();

    try (Session session = HibernateUtil.getSessionFactory().openSession()) {
        CriteriaBuilder cb = session.getCriteriaBuilder();
        CriteriaQuery<T> cq = cb.createQuery(clazz);
        Root<T> root = cq.from(clazz);

        List<Predicate> predicates = new ArrayList<>();

        // --- Full-text search on searchable fields ---
        if (keyword != null && searchableFields != null && !searchableFields.isEmpty()) {
            List<Predicate> orPredicates = new ArrayList<>();

            for (String field : searchableFields) {
                Path<?> path = getPath(root, field);

                // If field is LocalDateTime, convert to String before LIKE
                if (path.getJavaType().equals(LocalDateTime.class)) {
                    // This safely casts datetime to string for comparison
                    Expression<String> stringified = path.as(String.class);
                    orPredicates.add(cb.like(cb.lower(stringified), "%" + keyword + "%"));
                } else {
                    orPredicates.add(cb.like(cb.lower(path.as(String.class)), "%" + keyword + "%"));
                }
            }

            // Combine all OR predicates
            predicates.add(cb.or(orPredicates.toArray(new Predicate[0])));
        }

        // --- Exact filters from filters map ---
        for (Map.Entry<String, Object> entry : filters.entrySet()) {
            if (entry.getValue() == null) continue;

            Path<?> path = getPath(root, entry.getKey());

            if (entry.getValue() instanceof String s) {
                predicates.add(cb.like(cb.lower(path.as(String.class)), "%" + s.toLowerCase() + "%"));
            } else if (entry.getValue() instanceof LocalDate date) {
                // Match all timestamps inside that date
                LocalDateTime start = date.atStartOfDay();
                LocalDateTime end = date.atTime(LocalTime.MAX);
                predicates.add(cb.between(path.as(LocalDateTime.class), start, end));
            } else {
                predicates.add(cb.equal(path, entry.getValue()));
            }
        }

        cq.where(predicates.toArray(new Predicate[0]));
        return session.createQuery(cq).getResultList();
    }
}

    public List<T> search(Map<String, Object> filters,
                          String searchTerm,
                          List<String> searchableFields) {

        if (filters == null) filters = new HashMap<>();

        String keyword = (searchTerm == null || searchTerm.isBlank()) ? null : searchTerm.toLowerCase();

        try (Session session = HibernateUtil.getSessionFactory().openSession()) {
            CriteriaBuilder cb = session.getCriteriaBuilder();
            CriteriaQuery<T> cq = cb.createQuery(clazz);
            Root<T> root = cq.from(clazz);

            List<Predicate> predicates = new ArrayList<>();

            // --- Search fields (contains) ---
            if (keyword != null && searchableFields != null && !searchableFields.isEmpty()) {
                List<Predicate> orPredicates = new ArrayList<>();

                for (String field : searchableFields) {
                    Path<?> path = getPath(root, field);
                    orPredicates.add(cb.like(cb.lower(path.as(String.class)), "%" + keyword + "%"));
                }

                predicates.add(cb.or(orPredicates.toArray(new Predicate[0])));
            }

            // --- Exact match filters ---
            for (Map.Entry<String, Object> entry : filters.entrySet()) {
                if (entry.getValue() == null) continue;

                Path<?> path = getPath(root, entry.getKey());

                if (entry.getValue() instanceof String s)
                    predicates.add(cb.like(cb.lower(path.as(String.class)), "%" + s.toLowerCase() + "%"));
                else
                    predicates.add(cb.equal(path, entry.getValue()));
            }

            cq.where(predicates.toArray(new Predicate[0]));
            return session.createQuery(cq).getResultList();
        }
    }

    private Path<?> getPath(From<?, ?> root, String fieldPath) {
        String[] parts = fieldPath.split("\\.");
        Path<?> path = root.get(parts[0]);
        for (int i = 1; i < parts.length; i++) {
            path = path.get(parts[i]);
        }
        return path;
    }